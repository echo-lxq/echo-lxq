# 通信协议 #
## 一、网络分层架构 ##
![](./images/network_layer.png)

## 二、TCP和UDP协议 ##
### 1.UDP协议 ###
UDP（user Datagram Protocol）:用户报文协议<br>
没有任何特点<br>
和TCP对比：不可靠、无连接、面向报文<br>
**1.UDP作为一种简单的传输层协议，基本上没有什么操作来帮助用户处理复杂的网络环境，所以UDP保留下来这种不可靠的特性。**

**2.UDP报文的头信息(定长的(8字节))**
![](./images/udp_data.png)

**3.校验和（checksum）的作用和工作机制**<br>

- 判断收到的报文(数据)是否出现差错的
- 利用**hash函数**的原理：通过设计一种hash函数，达到冲突率很低的一种情况
 <br>**发送端**:checksum(payload)=>校验和1（把校验和1填写到UDP的header中）
 <br>**接收端**:checksum(payload)=>校验和2
 <br>**比较**校验和2和header中的校验和1：如果**不等**，payload在传输过程中一定**出现差错了**；如果**相等**，**大概率payload没有出现出错**
- 针对校验和可以对上的情况，**正常接收数据**。
 <br>针对校验和**对不上的情况，直接丢包**；UDP**不是特别可靠**

**4.UDP协议栈的作用**<br>

1. **计算校验和**
1. **填写正确的header信息**
1. **把header + payload一起交给网络层**(*重点：UDP没有**发送**缓冲区)
1. **网络层发送数据到网卡**
1. **send方法返回**
<br>*重点：我们在应用层调用send方法时方法返回了，就**意味着数据已经到达了网络层中**

接收到数据后

1. **计算校验和**
1. **解包**
1. **通知指定的进程，数据已经到达...这段期间**，进程可能还暂时来不及过来取数据。所以UDP协议栈需要找个地方把数据暂存一会儿。UDP协议栈中有**接收缓冲区**。

**5.UDP有接收缓冲区，没有发送缓冲区**<br>

用戶发送多少数据，UDP也会发送多少数据，所以**UDP是面向报文的**<br>
UDP发送数据无需任何准备工作，随时随地可以发送：寄件VS打电话，所以UDP是**无链接的**

**6.面向报文导致的一个后果**<br>

由于底层(物理层+网络层)都对**一次发送**的数据大小限制。如果强行发送大于限制的数据，就会出现数据被截断<br>
**全双工**：同一个通道是双向的

**7.UDP协议的最适合场景**<br>
对实时性要求较高、对可靠性要求较低的场景
实时聊天(语音、视频聊天)
UDP支持广播。如果有广播需求可以考虑UDP。

### 2.TCP协议 ###
TCP(Transmission Control Protocol):传输控制协议

**1.目标**<br>

- 以进程为单位传递数据
- 追求可靠性

**2.什么是可靠性**<br>
TCP只能保证自己最大的可能，把数据有序地发送给对方。但**不能保证一定发送给对方**<br>

1. 尽可能去**发送**给对方
1. 就算发不过去，也有**反馈**
1. 保证对方接收是**有序的**
1. 保证对方**不会收到差错数据**
1. **TC**会设计一些机制，来尽可能的**优化网络**，提高对方收到的可能性

**TCP使用什么样的机制，来保证可靠性 -- 确认应答机制**
![](./images/tcp_reliable.png)

    TCP发送的数据，一般被称为segment(数据段)

    应答：acknowledge

1. 如果发送方同时发送了多条segment，应答进行了多次应答。发送方如何得知，接收方收到的是那一次的segment?<br>
 **编号机制**：发送方为发送的数据做编号，应答的时候带上对应编号即可。
1. 如果接收方没有收到数据，则不会应答；或者接收方应答了。但应答丢包了<br>
 总之：发送方没有收到对应的应答。则认为对方没有收到数据 -- **超时重传机制**

**3.TCP协议的header格式**<br>
![](./images/tcp_segment.png)

1. 和UDP不同，TCP的header**不是定长**的。
1. 哪个或者哪些字段，可以保证接收方的**TCP协议栈进行解包**工作？<br>
**4位的header长度**
1. 根据源port+目标port做分用
1. 到目前为止，TCP发送的segment有两种：（1.**携带数据**segment 2.**应答** segment），TCP协议并没有把两种作用的segment进行不同格式的设计，而是进行**统一的设置**了！<br>
那具体怎么区分本次segment**是否具有应答**的作用呢？<br>
**ack == 1时segment有应答功能；ack==0时segment没有应答功能**
1. segment的可能情况(1)光携带数据；(2)携带数据+应答(网络中合并数据发送，可以提高网络发送的效率)
1. 32位序号：SN(sequence Number)<br>
32位确认序号：ASN(AckNowledge Sequence Number)

**4.SN和ASN书写规则**<br>

1. TCP为发送每个字节都进行**编号**(只是payload，没有header) [h e l l o]<br>
**h:108(随便选的)，e:109 ，l:110 ，l:111 ，0:112** 
1. **TCP协议栈**在建立链接时，会**随机一个初识序列号**(Initial Sequence Number ISN)**ISN:108**
1. 发送的时候，header中的**SN**填写的是payload中的**第一个字节的序列号**<br>
**[hello]<br>
SN:108<br>**
接收方是知道长度是5的，所以，接收方如果**收到数据**，则表示**108-112**已经全部收到了
1. ASN应该如何填写？**填写的是接收方期望收到的下一个字节的数据**<br>
上述例子中，**接收方要应答的话ASN应该填写113**。隐含的意思就是113之前的所有数据，已经全部接收到了。
![](./images/tcp_segment_trans.png)

5. 如果发送方**超过一定时间都没有收到应答**，则可能

![](./images/tcp_packet_loss_o.png)
![](./images/tcp_packet_loss_t.png)

发送方的处理逻辑是一致的。超时之后，直接重传即可(重传的数据不会丢失)，不需要区分情况

6 . 如果**乱序**到达怎么办？

![](./images/tcp_out_order.png)

对于发送方，收到了一个应答segASN=x时，发送方是怎么理解这个信号的？<br>
对方已经收到收到了x-1之前的所有数据了。<br>
**TCP协议是有接收缓冲区的，保证对方接收是有序的**(接收端可以重新整理数据，接收过得数据不再接收)

**如果超时之后，重传对方仍然没有收到，怎么办？**<br>
继续重传，直到到达一个阈值（假设6次）。如果6次，我都没有收到应答。我就认为不需要再努力的，放弃：

1. 尽人事，试图通知对方，链接异常关闭了---通过发送一个reset segment(另一种)。<br>
rst = 1，reset segment<br>
rst = 0，不是reset segment<br>
1. 通过我们的应用层，数据发送失败了。(Java中是通过异常的方式通知的，会收到一个IOException(SocketException)描述reset connection)

**5.链接管理（Connection Message）**<br>

为什么需要链接（链接是什么抽象）?

1. 作为TCP协议栈，是需要维护一个**接受缓冲区**的。<br>
	①.保证整理乱序到达的数据<br>
    ②.在数据暂时未被应用层读走之前，临时保存数据

1. 作为TCP协议栈，是需要维护一个**发送缓冲区**的。<br>
	因为要考虑重发的可能性，所以未应答的数据不能直接扔掉，所以需要一个空间暂存<br>
	例：send("hello")成功，代表数据被发送到OS的TCP协议栈的发送缓冲区中

1. 作为TCP协议栈<br>
	发送方时，需要维护**已经发送的SN**<br>
	接收方时，需要维护**应该应答的SN**

上述3点，足以说明：TCP协议栈，为了保证之前的那些机制可用，**必须为每个信道，维护一组相关的数据**！！

**6.建立连接的必要性**<br>

![](./images/tcp_ISN.png)

1. 由于TCP是追求可靠的，所以TCP在正式发送之前，想验证下对象是否能收到我的数据。<br>
类比:寄信 + 电话

1. Connection对象，有一部分信息是无法独立知道的，需要双方进行有效信息的同步

![](./images/tcp_connect_test.png)

**TCP的建立链接，需要双方交换几次信息---三次---三次握手**<br>
[为什么是三次？]

![](./images/tcp_ab_two.png)

TCP是需要保证可靠性的，所以，任意数据(除了应带，reset)都需要进行应答

![](./images/tcp_ab_four.png)

(2)、(3) 事实上，总是可以同时发送的，为了提升网络利用率，所以合并(2)、(3)

![](./images/tcp_ab_three.png)

四种segment:数据segment、应答segment(ack=1)、reset segment(rst=1)、同步segment(syn=1)

	1. 什么是链接，为什么TCP需要有链接，UDP就没有链接。
	   逻辑上对信道的抽象。物理上各自内存中维护的信道相关的一组数据。
	   因为TCP为了追求可靠性引入一系列机制（确认应答机制，超时重传机制），为了这些机制能正常的工作，是的TCP必须引入链接的概念。
	2. 建立链接阶段的必要性
	   互相确认对象在线
	   双方同步必要的初识信息
	3. 	为什么要三次握手

## 三、域名解析及为什么选用UDP协议 ##
1.
http://news.sohu.com/a/529566154_657867